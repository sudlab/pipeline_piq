"""===========================
Pipeline template
===========================

.. Replace the documentation below with your own description of the
   pipeline's purpose

Overview
========

This pipeline computes the word frequencies in the configuration
files :file:``pipeline.yml` and :file:`conf.py`.

Usage
=====

See :ref:`PipelineSettingUp` and :ref:`PipelineRunning` on general
information how to use CGAT pipelines.

Configuration
-------------

The pipeline requires a configured :file:`pipeline.yml` file.
CGATReport report requires a :file:`conf.py` and optionally a
:file:`cgatreport.ini` file (see :ref:`PipelineReporting`).

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_piq.py config

Input files
-----------

None required except the pipeline configuration files.

Requirements
------------

The pipeline requires the results from
:doc:`pipeline_genesets`. Set the configuration variable
:py:data:`annotations_database` and :py:data:`annotations_dir`.

On top of the default CGAT setup, the pipeline requires the following
software to be in the path:

.. Add any additional external requirements such as 3rd party software
   or R modules below:

Requirements:

* samtools >= 1.1

Pipeline output
===============

.. Describe output files of the pipeline here

Glossary
========

.. glossary::


Code
====

"""
import sys
import os
from ruffus import transform, regex, suffix, follows, mkdir, split, formatter
from ruffus.combinatorics import product

from CGATCore import Pipeline as P

# load options from the config file
PARAMS = P.get_parameters(
    ["%s/pipeline.yml" % os.path.splitext(__file__)[0],
     "../pipeline.yml",
     "pipeline.yml"])

PARAMS["COMMONSCRIPT"] = os.path.join(PARAMS["PIQ_PATH"], "common.r")


# ---------------------------------------------------
# Specific pipeline tasks
@follows(mkdir("motif.matchs"))
@split(os.path.join(PARAMS["PIQ_PATH"], "pwms/jasparfix.txt"),
       ["motif.matchs/%i.pwmout.RData" % (i+1) for i in range(1320)])
def process_pwms(infile, outfiles):

    statements = []
    statement = []
    match_script = os.path.join(PARAMS["PIQ_PATH"], "pwmmatch.exact.r")
    out_dir = os.path.dirname(os.path.abspath(outfiles[0]))
    job_memory = "8G"
    
    statement_template = "Rscript %%(match_script)s %%(COMMONSCRIPT)s %%(infile)s %(i)i %%(out_dir)s"
    
    for i in range(1,1321,1):
        statement.append(statement_template % locals())
        if len(statement) == PARAMS["chunk_size"]:
            statements.append("cd %(PIQ_PATH)s && "+ " && ".join(statement))
            statement = []

    statements.append( "&&".join(statement))
    
    P.run(statements, job_condaenv=PARAMS["piq_condaenv"])

@follows(mkdir("processed_bams.dir"))    
@transform("*.bam", formatter(), "processed_bams.dir/{basename[0]}.RData")
def process_bam(infile, outfile):

    infile = os.path.abspath(infile)
    outfile = os.path.abspath(outfile)
    bam2rdata_script = os.path.join(PARAMS["PIQ_PATH"], "bam2rdata.r")
    statement = '''cd %(PIQ_PATH)s &&
                   Rscript %(bam2rdata_script)s %(COMMONSCRIPT)s %(outfile)s %(infile)s'''
    job_memory = "64G"
    
    P.run(statement, job_condaenv=PARAMS["piq_condaenv"])


@follows(mkdir("calls.dir"))
@product(process_bam,
         formatter(),
         process_pwms,
         formatter("motif.matchs/(?P<PWM>.+).pwmout.RData"),
         "calls.dir/{basename[0][0]}/{PWM[1][0]}.done")
def call_matches(infiles, outfile):

    bamfile, pwm = infiles

    bamfile = os.path.abspath(bamfile)
    matchesdir = os.path.abspath(os.path.dirname(pwm))
    pwm_no = P.snip(os.path.basename(pwm), ".pwmout.RData")
    outfile = os.path.abspath(outfile)  
    pertf_script = os.path.join(PARAMS["PIQ_PATH"], "pertf.r")
    outdir = os.path.dirname(os.path.abspath(outfile))
    statement = '''cd %(PIQ_PATH)s &&
                   Rscript %(pertf_script)s 
                            %(COMMONSCRIPT)s 
                            %(matchesdir)s/  
                            $TMPDIR 
                            %(outdir)s 
                            %(bamfile)s
                            %(pwm_no)s &&
                  rm -rf $TMPDIR/* &&
                  touch %(outfile)s'''

    # Memory usage depends on input size

    size = os.path.getsize(pwm)
    size = size/(1024.0*1024.0)

    bamsize = os.path.getsize(bamfile)
    bamsize = bamsize/(1024.0*1024.0)

    if bamsize > 700:
        size += 15

    if size > 60:
        job_memory = "128G"
    elif size > 45:
        job_memory = "64G"    
    elif size > 30:
        job_memory = "32G"
    elif size > 15:
        job_memory = "16G"
    elif size > 5:
        job_memory = "8G"
    else:
        job_memory = "4G"

    P.run(statement, job_condaenv = PARAMS["piq_condaenv"])


# ---------------------------------------------------
# Generic pipeline tasks
@follows(call_matches)
def full():
    pass


def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)


if __name__ == "__main__":
    sys.exit(P.main(sys.argv))    
